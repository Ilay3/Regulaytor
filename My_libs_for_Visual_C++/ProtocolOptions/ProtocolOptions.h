/********************************************************************
*********************************************************************
**		В связи с переходом на библиотеки, приходится уходить от конс-
**	тант, определяемых как #define, т.к. в этом случае одна библиотека
**	годилась бы только одному приложению. Эта структура определяет фор-
**	мат протокола приёмо-передачи и должна загружаться во время выполнения
**	программы.
*************************************************************************
************************************************************************/

/*******************	ЛИСТ РЕГИСТРАЦИИ ИЗМЕНЕНИЙ	*****************************
*	16.11.2006 - создан
*	27.11.2006 - введена опция OptimazeInMessageView, которая в свете последних событий
*				с тормозами Windows при большой частоте обмена оказалась очень полезной
*	30.11.2006 - введен указатель на функцию OnVerify, еще один шаг к библиотечной версии
*	4.12.2006 - теперь можно принимать сообщения длиной больше 255 байт
*	27.12.2006 - добавлена переменная var_DAT_STATE
*	02.02.2007 - добавлено свойство AutoClearMessageCounter
*	14.04.2007 - добавлены старые опции из программы (с префиксом о_), а также указатели на
*				функции компоновки сообщений
*	18.06.2007 - добавлена переменная var_PORT_NUMBER
*	14.09.2007 - определены константы оргументов функции NotifyProgram
*	5.10.2007 - добавлена настройка o_LogInMessage
*	10.10.2007 - убрали o_DoHistoryFile, добавили o_LogTimeMessages и o_Period и o_EmulSpeed
*	12.10.2007 - добавили var_RS485EN
*	3.08.2008 - удалил AutoClearMessageCounter, теперь, если будет нужно - лучше буду стирать
*				по щелчку правой кнопкой.
*	14.08.2008 - PN_NOT_INITIALIZE заменён на PN_NOTINITIALIZED
*	21.09.2008 - убрал не относящуюся к связи переменную o_LogFile
*	08.10.2008 - PN_FIRST_AVALABLE заменён на PN_FIRST_AVAILABLE
*********************************************************************************/

#pragma once
#include "MessageClass\MessageClass.h"		//класс отправляемого сообщения
#include "types_visual_c++.h"				//мои типы данных
#include <vector>

using namespace std;

/*******************	КОНСТАНТЫ ДЛЯ РЕЖИМОВ ПРИЕМОПЕРЕДАЧИ	******************/
#define BYTE_STUFFING	0	
	/*
	 *	Включен протокол с элементарным байт-стаффингом.
	 *  Начало пакета отслеживается по стартовому байту. Появление стартового байта
	 *  в данных подтверждается байт-стаффингом. Содержимое принимаемого пакета
	 *  контролируется в процессе его формирования (длина, данные, контрольная сумма).
	 */

#define PACKET_LEN		1
	/*
	 *  Протокол с фиксированным полем длины, внутри сообщения могут быть любые символы,
	 *  четко отслеживается конец пакета (по длине).
	 */

#define	EXTERN_FUNC		2
	/*
	 *  В этом режие при приеме очередного пакета все действия с ним
	 *  передаются во внешнюю функцию пользователя
	 */

struct POTOCOL_OPTIONS_Struct
{
	/************************* РЕЖИМ ПРИЕМОПЕРЕДАЧИ *****************************
	*	При приеме сообщения могут использоваться разные алгоритмы приема. Сделать 
	*	универсальный - не получается, поэтому придется выбирать.
	*	Для простоты, введены константы, описанные выше.
	******************************************************************************/
	unsigned char	var_Regime;	// PACKET_LEN - фиксированное поле длины
								// BYTE_STUFFING - пакеты с байтстаффингом
								// EXTERN_FUNC - при приеме символа вызывается внешняя функция

	/************************	var_STUF_BYTE	*********************************
	*	Эта переменная имеет смыст только в режиме с байтстаффингом и определяет,
	*	какой байт будет расценен как байтстаффинг
	*****************************************************************************/
	unsigned char	var_STUF_BYTE;

	
	/*********************	var_LEN_STATE	************************************
	*		Эта переменная имеет смысл только в режиме с полноценным пакетом.
	*	номер байта в посылке (начиная с 0), в котором лежит длина сообщения.
	****************************************************************************/
	unsigned char	var_LEN_STATE; 

	/*********************	var_LEN_ADD	************************************
	*		Эта переменная имеет смысл только в режиме с полноценным пакетом.
	*	если в поле длины указывапется длина не всего пакета
	*	(а например только поля данных), то здесь содержится число, 
	*	которое нужно добавить.
	**************************************************************************/
	unsigned char	var_LEN_ADD;

	#define PN_FIRST_AVAILABLE 0xFF		//Инициализируется первый свободный порт (действует только при старте)
	#define PN_NOTINITIALIZED 0xFE		//Никакой из портов не инициализирован изначально, или при последней
										//инициализации возникли ошибки
	INT8U			var_PORT_NUMBER;	//Номер последовательного порта, на который настроена программа, или
										//Номер последовательного порта при старте (сразу после запуска программы)

	unsigned int	var_TRANSFER_SPEED;	//скорость передачи
	unsigned char	var_BITS_PER_PACKET;//бит в байте (ну, в общем, умный меня понял...)
	unsigned char	var_STOP_BITS;		//стоповых битов
	INT8U			var_PARITY;			//контроль четности
										//'N' - нет контроля
	bool			var_RS485EN;		//Если выставлен этот флаг, то модуль USART при передаче 
										//сообщения автоматом взводит и сбрасывает RTS пин порта

	unsigned char	var_FIRST_BYTE;		//первый байт, с котрого начинается посылка
	unsigned char	var_ID_STATE;		//положение в пакете идентификатора отправителя (или предназначенца, зависит от протокола)
	unsigned char	var_MT_STATE;		//Message Type, положение в пакете байта - идентификатора типа сообщения
	unsigned char	var_DAT_STATE;		//с какого байта в пакете начинаются данные
	unsigned char	var_SUM_OFFSET;		//на сколько байт от конца отстоит чек-сумма(1 - последний байт)
	unsigned short	var_MAX_LEN	;		//максимальная длина сообщения в байтах

	unsigned char	var_MY_ID;			//идентификатор компьютера
	unsigned char	var_KONTROLLER_ID;	//идентификатор контроллера

	/***************	OptimazeInMessageView	*********************************
	*		Эта переменная позволяет управлять отображением принимаемого сообщения
	*	на экране. 
	*	true - На экране отображаются только корректно принятые сообщения, причем только
	*			после приема всего сообщения. Информация о принятом сообщении отбражается 
	*			в это же время. Этот режим лучше включать только перед сдачей программы в
	*			эксплуатацию, или при очень скоростном обмене
	*	false - Каждый принятый символ будет отображен на экране незамедлительно после его 
	*			приема (собственно, как и информация о состоянии принимаемой посылке). Этот режим
	*			очень полезен при отладке, хотя и сильно грузит систему
	*********************************************************************************/
	bool OptimazeInMessageView;

	/****************	CURRENT_SUMM(x,y,z)	*************************************
	*	Указатель на функцию, которая будет подсчитывать контрольную сумму. Сумма
	*	считается после приема ЦЕЛОГО пакета.
	*****************************************************************************/
	unsigned char (*CURRENT_SUMM)(unsigned char *,short,short);	

	/****************	(*ExternReceiveChar) (unsigned char char)	*************
	*	Указатель на функцию, которая будет обрабатывать получение очередного 
	*	символа, если ни режим PACKET_LEN ни BYTE_STUFFING не устраивают, то вы
	*	зывается эта функция
	*****************************************************************************/
	bool (*ExternReceiveChar) (unsigned char ch);

	/**************	(*OnVerify) (CString * err, unsigned char *pReceiveMessage)	**********
	*		Это указатель на функцию, которой будут передаваться все правильно принятые пакеты
	*	для расшифровки.
	**************************************************************************************/
	bool (*OnVerify) (CString * err, unsigned char *pReceiveMessage);



	/*****************************************************************************
	*	СЛЕДУЮЩИЕ ОПЦИИ ПЕРЕКОЧЕВАЛИ СЮДА ИЗДРЕВНА
	******************************************************************************/
	//ПЕРЕМЕННЫЕ НАСТРОЙКИ МОЕЙ ПРОГРАММЫ
	bool o_emulation;//нужна ли эмуляция приемо-передачи
   	// распознавать ли все сообщения
	bool o_verify;
	// путь к файлу листинга принятых сообщений
	CString o_inMesFile;
	// передавать ли непрерывно
	bool o_nepr;
	// вести ли передачу из файла?
	bool o_OFF;
	// имя файла, из которого будут отправляться сообщения
	CString o_outMesFile;
	
	// отображать не строки, а шестнадцатеричные значения в окнах программы
	bool o_HexDisplayOutMessage;
	// показывать ли шестнадцатеричные значения при приеме
	bool o_HexDisplayInMessage;
	// нужно ли фиксировать отправляемые сообщения в файле
	bool o_LogOutMessage;
	// нужно ли фиксировать принимаемые сообщения в файле
	bool o_LogInMessage;
	// нужно ли писать время отправляемых и принимаемых сообщений
	bool o_LogTimeMessages;
	// отображать байты синхронизации в принимаемых сообщениях
	bool o_LogInByteStuffing;
	//период передачи символов при эмуляции
	INT16U o_EmulSpeed;
	//период передачи сообщений при непрерывной передаче
	INT32U o_Period;

	//тип сообщения по значению в поле L_DAT: 0-длина пакета без учета CS (L_DAT=7)/1-с учетом CS (L_DAT=8)
	bool   o_MsgType;
	//старый способ передачи сообщения - передаются оба варианта сообщений последовательно 
//	#define  MSG_TX_OLD_TYPE

//КОНЕЦ ПЕРЕМЕННЫХ НАСТРОЙКИ

	/*******************************************************************************
	*	Следующий контейнер указателей на внешние функции, которые будут компилировать
	*	посылки (очередной шаг к библиотечной структуре)
	********************************************************************************/

	#define MSG_L_DAT_TYPE_INC_CS	1
	#define MSG_L_DAT_TYPE_EXC_CS	0
	#define MSG_L_DAT_TYPE			MSG_L_DAT_TYPE_EXC_CS
	vector<bool (*)(CMessage&)> CompileMessage_x;
	/*bool (*CompileMessage_1)(CMessage* pNextMessage); //собирает NextMessage_1 из главного класса
	bool (*CompileMessage_2)(CMessage* pNextMessage); //собирает NextMessage_2 из главного класса
	bool (*CompileMessage_3)(CMessage* pNextMessage); //собирает NextMessage_3 из главного класса
	bool (*CompileMessage_4)(CMessage* pNextMessage); //собирает NextMessage_4 из главного класса
	bool (*CompileMessage_5)(CMessage* pNextMessage); //собирает NextMessage_5 из главного класса
	bool (*CompileMessage_6)(CMessage* pNextMessage); //собирает NextMessage_6 из главного класса
	bool (*CompileMessage_7)(CMessage* pNextMessage); //собирает NextMessage_7 из главного класса
	bool (*CompileMessage_8)(CMessage* pNextMessage); //собирает NextMessage_8 из главного класса
	*/
	/**********************************************************************************
	*		Эта функция будет вызываться, когда требуется уведомить главную программу
	*	о событиях, которые происходят со связью. При этом flags будет отвечать за тип 
	*	события.
	*************************************************************************************/
	#define NP_MESSAGE_TRANSFERED		0x01	//какое-то сообщение отправлено
	#define NP_RECEIVE_PROTOCOL_ERROR	0x02	//ошибка при приеме на уровне протокола (например в контрольной сумме)
	#define NP_MESSAGE_RESEIVED			0x03	//какое-то сообщение принято (вызывается одновременно с OnVerify)
	#define NP_TRANSFER_ERROR			0x04	//ошибка при передаче на уровне драйвера
	void (*NotifyProgram)(INT32U flags);

	POTOCOL_OPTIONS_Struct()//конструктор
	{//проведем начальную инициализацию
		var_Regime=0xFF;
		var_STUF_BYTE=0;
		var_LEN_ADD=0;
		var_PORT_NUMBER=-1;
		var_TRANSFER_SPEED=0;
		var_BITS_PER_PACKET=0;
		var_STOP_BITS=0;
		var_PARITY=0;
		var_RS485EN=false;
		var_FIRST_BYTE=0;
		var_ID_STATE=0;
		var_MT_STATE=0;
		var_DAT_STATE=0;
		var_SUM_OFFSET=0;
		var_MAX_LEN=0;
		var_MY_ID=0;
		var_KONTROLLER_ID=0;
		ExternReceiveChar=NULL;
		CURRENT_SUMM=NULL;
		OnVerify=NULL;
		OptimazeInMessageView=false;
		o_emulation=false;
		o_verify=true;
		o_inMesFile="ReceivedMessages.txt";
		o_nepr=false;
		o_OFF=false;
		o_outMesFile="OutMessage.txt";
		o_HexDisplayOutMessage=true;
		o_HexDisplayInMessage=true;
		o_LogOutMessage=false;
		o_LogInMessage=true;
		o_LogTimeMessages=false;
		o_LogInByteStuffing = false;
		//o_MsgType=0;
		o_Period=500;
		//сбросим на ноль функции - оповестители процесса приемопередачи
		NotifyProgram=NULL;
	}
};