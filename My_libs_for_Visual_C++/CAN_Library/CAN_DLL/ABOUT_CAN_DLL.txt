В этом файле я постарался привести описание динамической библиотеки CAN_DLL.dll
Библиотека работает в режиме UNICODE и не использует MFC.

Чтобы ее добавить к проекту необходимо:
1. В директорию проекта скинуть файлы CP210xManufacturing.dll, CAN_DLL.dll, CAN_DLL.lib и CAN_DLL.h.
2. В заголовочном файле (например stdafx.h) прописать 
		#pragma comment(lib,"CAN_DLL.lib")
		#include "CAN_DLL.h"
3. Впоследствии не забыть с .exe файлом своей программы таскать CAN_DLL.dll и CP210xManufacturing.dll

4. Библиотека не требует какой-либо особой инициализации, однако, чтобы
внешнаяя прогрмамма уведомлялась о приеме нового CAN сообщения необходимо
до начала работы (например в функции OnInitDialog) передать указатель на окно:
		if(CAN_SetMesReceiveWindow(this->m_hWnd)!=CR_ALLOK)	return FALSE;
		
5. При получении очередного CAN сообщения, либо по какому другому событию,
программа посылает окну, хэндл которого ранее был задан функцией CAN_SetMesReceiveWindow, 
сообщение. Для этого нужно:
	a. Добавить ON_MESSAGE(MSG_NEW_RECEIVE,ReceiveCAN_Message)
	b. Добавить LRESULT ВАШ_ДИАЛОГ::ReceiveCAN_Message(WPARAM pMessage, LPARAM Code)
	c. pMessage использовать как указатель на принятое CAN сообщение типа CCAN_Message
	d. Если pMessage==NULL, то используя Code можно расшифровать событие с преобразователем
			CTF_STATE_CHANGED	- изменилось состояние подключен/отключен преобразователя CAN-USB (пока не полностью)
			CTF_UNCOWN_CONFIRM	- преобразователь отправил подтверждение отправки незапрашиваемого сообщения
	
6. Установите драйвера для CP2102 и подключите преобразователь.

В каждый момент времени пользователь может перевести преобразователь в один из 3-х режимов 
работы:
	RG_NORMAL	-	Преобразователь работает с сетью CAN на заранее
					установленной скорости, отображает принятые сообщения, доступны
					изменение скорости, фильтров, масок, отправка своих сообщений.
					Это основной режим работы

	RG_SPEEDFIND -	Если в исследуемой сети неизвестна скорость, то преобразо-
					ватель может попытаться найти ее. При этом в сети должно 
					быть два общающихся между собой узла. В режиме недоступна
					отправка сообщений, ручное изменение скорости, изменение
					фильтров и маски.
					
	RG_AUTOSEND -	Если на объекте физически проложена CAN сеть, то ее можно легко
					исследовать в этом режиме. Преобразователь автономно (без
					общения с компьютером) периодически отправляет сообщения
					разной длины/идентификаторов. Т.е. работает как радиомаячок.
					Остается только решить проблему с питанием платки
					
	Режимы RG_NORMAL и RG_AUTOSEND сохраняются в энергонезависмой памяти и при 
последующем включении преобразователя он автоматически переходит в них. В режиме 
RG_AUTOSPEED после перезагрузки преобразователь входит в режим RG_NORMAL.

	Т.к. практически все функции общаются с преобразователем по интерфейсу связи,
то их выполнение занимает достаточно много времени и пользоваться ими нужно только
в случае необходимости. Более того, если преоброзователь завис и не хочет отвечать,
то выполняемая функция выжидает определенное время (по умолчанию 1 секунда) и только
потом возвращает управление с соответсвующим флагом.

	Имеется возможность настраивать фильтры и маски. Для чего это нужно? Допустим по 
сети со скоростями 1 МБит гонится целая куча сообщений и ни преобразователь, ни,
тем более компьютер не успевает их обрабатывать. Тогда я настраиваюсь только на 
прием нужных мне сообщений и живу спокойно. Чтобы полностью вникнуть в технику 
нужно почитать datasheet на PIC18, однако, например, если нужно принимать 5 различных
сообщений, то загоняем в маску все FF, а в фильтры идентификаторы нужных сообщений.


							ОПИСАНИЕ ФУНКЦИЙ

/*************************    CAN_SetMesReceiveWindow    ***************************
*		Устанавливает указатель на окно, которое будет принимать сообщения по CAN
*	hWnd - хэндл окна
*	Если все нормально, то возвращает CR_ALLOK. Если что-то не то с хэндлом, то
*	CR_BADARGUMENTS
************************************************************************************/						
CAN_RESULT	CAN_SetMesReceiveWindow(HWND hWnd)

/**************************    CAN_IsMonitorConnected   ****************************
*		Данная функция определяет - подключен ли преобразователь к компьютеру
*	или нет.
*		true - преобразователь подключен и CP2102 инициализирована, либо была 
*				принудительная инициализация через функцию CAN_COM_Open
*		false - не подключен
***********************************************************************************/
CAN_DLL_API bool CAN_IsMonitorConnected()

/*************************    CAN_SetTimeOut    ***********************************
*		Устанавливает тайм-аут ожидания ответа преобразователя.
*	time_ms - время тайм-аута в миллисекундах. Должно быть не меньше 10 мс.
*	Если все нормально, то возвращает CR_ALLOK. Если что-то не то с time_ms, то
*	CR_BADARGUMENTS
***********************************************************************************/
CAN_RESULT CAN_SetTimeOut(DWORD time_ms)

/************************    CAN_GetTimeOut    *************************************
*		Возвращает установленный тайм-аут ожидания ответа преобразователя.
***********************************************************************************/
DWORD	CAN_GetTimeOut(void)

/************************    CAN_GetReceiveErrorsCount    ************************
*		Возвращает количество ошибок при приеме (по спецификации CAN 2.0B).
*		pCount - указатель на переменную, которая будет принимать результат.
*		Возвращаемые значения:
*	Если все прошло нормально			- CR_ALLOK
*	pCount равно NULL					- CR_BADARGUMENTS
*	Если преобразователь не подключет	- CR_NOTCONNECTED
*	Если преобразователь не отвечает	- CR_NOANSWER
*	Другие непонятные ошибки			- CR_OTHERERROR
************************************************************************************/
CAN_RESULT CAN_GetReceiveErrorsCount(unsigned char* pCount)

/************************    CAN_GetTranceiveErrorsCount    ************************
*		Возвращает количество ошибок при передаче (по спецификации CAN 2.0B).
*		pCount - указатель на переменную, которая будет принимать результат.
*		Возвращаемые значения:
*	Если все прошло нормально			- CR_ALLOK
*	pCount равно NULL					- CR_BADARGUMENTS
*	Если преобразователь не подключет	- CR_NOTCONNECTED
*	Если преобразователь не отвечает	- CR_NOANSWER
*	Другие непонятные ошибки			- CR_OTHERERROR
************************************************************************************/
CAN_RESULT CAN_GetTranceiveErrorsCount(unsigned char* pCount)

/***********************    CAN_GetBusOff     ***************************************
*	Проверяет преобразователь на состояние "Bus-Off" (по спецификации CAN)
*		pBusOff - указатель на переменную, которая будет принимать результат
*	Возвращаемые значения:
*		CR_ALLOK						- функция успешно отработала
*		pBusOff равно NULL				- CR_BADARGUMENTS
*		CR_NOTCONNECTED					- преобразователь не подключен к компьютеру
*		CR_NOANSWER						- преобразователь не отвечает на запросы
*		CR_OTHERERROR					- другая ошибка
*		*pBusOff ==	true  - преобразователь находится в состоянии Bus-Off
*					false - в активном состоянии
************************************************************************************/
CAN_RESULT CAN_GetBusOff(bool *pBusOff)

/**********************    CAN_GetSpeed      ***************************************
*		Возвращает скорость CAN, на которую настроен контроллер.
*		pBaudRate - указатель на переменную, которая будет получать скорость 
*					CAN в бодах.
*	Возвращаемые значения:
*		Если все прошло нормально			- CR_ALLOK
*		pCount равно NULL					- CR_BADARGUMENTS
*		Если преобразователь не подключет	- CR_NOTCONNECTED
*		Если преобразователь не отвечает	- CR_NOANSWER
*		Другие непонятные ошибки			- CR_OTHERERROR
***********************************************************************************/
CAN_RESULT	CAN_GetSpeed(DWORD* pBaudRate)

/***********************    CAN_SetSpeed     ***************************************
*		Выставляет скорость сети CAN на преобразователе. Т.к. преобразователь может
*	настроиться только на определенные скорости, то в фукнция автоматически подбират
*	наиболее подходящую. Однако может получиться так, что разность уставки и актуальной
*	скоростей будет слишком большой. Поэтому перед испльзованием этой функции реко-
*	мендуется воспользоваться функцией CAN_CalcActualSpeed, чтобы найти ошибку.
*		BaudRate - требуемая скорость в бодах.
*	Возвращаемые значения:
*		Если все прошло нормально			- CR_ALLOK
*		Если преобразователь не подключет	- CR_NOTCONNECTED
*		Если преобразователь не отвечает	- CR_NOANSWER
*		Другие непонятные ошибки			- CR_OTHERERROR
***********************************************************************************/
CAN_RESULT	CAN_SetSpeed(DWORD BaudRate)

/***********************    CAN_CalcActualSpeed    ********************************
*		Вычисляет наиболее подходящую физически возможную скорость CAN на которую 
*	может быть настроен преобразователь.
*		BaudRate	- желаемая скорость CAN в бодах
*		pError		- указатель на переменную, которая будет принимать относительную 
*					ошибку в процентах между возможной и желаемой скоростями.
*					Если NULL, то ошибка не вычисляется.
*		pActualSpeed - указатель на переменную, которая будет принимать ближайшую
*					физически возможную скорость CAN, на которую может быть настроен 
*					преобразователь. Если NULL, то скорость не вычисляется.
*	Возвращаемые значения:
*		Если все прошло нормально			- CR_ALLOK
*		Если преобразователь не подключет	- CR_NOTCONNECTED
*		Если преобразователь не отвечает	- CR_NOANSWER
*		Другие непонятные ошибки			- CR_OTHERERROR	
**********************************************************************************/
CAN_RESULT	CAN_CalcActualSpeed(DWORD BaudRate, float* pError, DWORD* pActualSpeed)

/**********************    CAN_SetRegime    ************************************
*		Устанавливает режим работы преобразователя. (см. общее описание)
*		Regime - требуемый режим работы. Одно из трёх значений 
*					RG_NORMAL, RG_SPEEDFIND, RG_AUTOSEND
*	Возвращаемые значения:
*		Если все прошло нормально			- CR_ALLOK
*		неизвестный Regime					- CR_BADARGUMENTS
*		Если преобразователь не подключет	- CR_NOTCONNECTED
*		Если преобразователь не отвечает	- CR_NOANSWER
*		Другие непонятные ошибки			- CR_OTHERERROR
**********************************************************************************/
CAN_RESULT CAN_SetRegime(BYTE Regime)

/************************     CAN_GetRegime     ***********************************
*		Возвращает режим работы преобразователя.
*		pRegime	- указатель на переменную, которая будет принимать текущий режим.
*	Возвращаемые значения:
*		Если все прошло нормально			- CR_ALLOK
*		pRegime==NULL						- CR_BADARGUMENTS
*		Если преобразователь не подключет	- CR_NOTCONNECTED
*		Если преобразователь не отвечает	- CR_NOANSWER
*		Другие непонятные ошибки			- CR_OTHERERROR
***********************************************************************************/
CAN_RESULT	CAN_GetRegime(BYTE* pRegime)

/**************************    CAN_SendMessage     **********************************
*		Отправляет по сети CAN сообщение.
*	pCAN_Message - указатель на отправляемое сообщение
*		Возвращаемые значения:
*	CR_ALLOK		- сообщение успешно отправлено
*	CR_NOTCONNECTED - преобразователь не подключен
*	CR_BADARGUMENTS - pCAN_Message равен NULL или сообщение некорректно
*	CR_DEVICEBUSY	- преобразователь не смог отправить сообщение, видно он не подк-
*						лючен к CAN сети или настроен не на ту скорость
*	CR_NOANSWER		- преобразователь не отвечает 
*	CR_OTHERERROR	- другие непонятные ошибки
************************************************************************************/
CAN_DLL_API CAN_RESULT CAN_SendMessage(CCAN_Message* pCAN_Message)

/*****************************     CAN_SetFilter     *******************************
*		Изменяет значение фильтра входящих сообщений на преобразователе.
*		FilterNum			- номер фильтра от 0 до 15
*		FilterValue			- Значение фильтра, которое нужно установить
*								от 0 до (2^11)-1 если фильтр стандартный
*								от 0 до (2^29)-1 если фильтр расширенный
*							Если значение вылезает за допустимые рамки, то 
*							оно просто обрезается.
*		IsFilterExtended	-	true - фильтр для расширенных сообщений
*								false - для стандартных
*	Возвращаемые значения:
*		Если все прошло нормально			- CR_ALLOK
*		Недопустимый номер фильтра			- CR_BADARGUMENTS
*		Если преобразователь не подключет	- CR_NOTCONNECTED
*		Если преобразователь не отвечает	- CR_NOANSWER
*		Другие непонятные ошибки			- CR_OTHERERROR
************************************************************************************/
CAN_RESULT CAN_SetFilter(BYTE FilterNum, DWORD FilterValue, bool IsFilterExtended)

/*****************************    CAN_GetFilter     **************************************
*		Возвращает значение, режим и включенность/выключенность фильтра.
*	FilterNum - номер фильтра от 0 до 15
*	pFilterValue		- сюда будет записано значение фильтра
*	pIsFilterExtended	- сюда будет записано является ли фильтр расширенным
*							true	- расширенный идентификатор
*							false	- стандартный идентификатор
*	pIsFilterEnable		- сюда будет записановключен ли фильтр
*							true	- да
*							false	- нет
*	pFilterValue,pIsFilterExtended,pIsFilterEnable м.б. нулевыми, в этом случае в 
*	соответствующие позиции результат не пишется.
*	Возвращаемые значения:
*		Если все прошло нормально			- CR_ALLOK
*		Недопустимый номер фильтра			- CR_BADARGUMENTS
*		Если преобразователь не подключет	- CR_NOTCONNECTED
*		Если преобразователь не отвечает	- CR_NOANSWER
*		Другие непонятные ошибки			- CR_OTHERERROR
*****************************************************************************************/
CAN_RESULT	CAN_GetFilter(BYTE FilterNum, DWORD *pFilterValue, bool* pIsFilterExtended, bool* pIsFilterEnable)

/*****************************    CAN_EnableFilter    ************************************
*		Включает/отключает работу фильтра идентификаторов сети CAN на преобразователе
*	FilterNum	- номер фильтра от 0 до 15
*	IsEnable	- true  - фильтр нужно включить
*				  false - фильтр нужно выключить
*	Возвращаемые значения:
*		Если все прошло нормально			- CR_ALLOK
*		Недопустимый номер фильтра			- CR_BADARGUMENTS
*		Если преобразователь не подключет	- CR_NOTCONNECTED
*		Если преобразователь не отвечает	- CR_NOANSWER
*		Другие непонятные ошибки			- CR_OTHERERROR
*****************************************************************************************/
CAN_RESULT	CAN_EnableFilter(BYTE FilterNum, bool IsEnable)

/********************    CAN_SetMask    **********************************************
*		Изменяет значение маски для фильтров входящих сообщений на преобразователе.
*		MaskValue - новое значение маски от 0 до (2^29)-1
*					Если значение превышает допустимые пределы, то оно просто обрезается.
*	Возвращаемые значения:
*		Если все прошло нормально			- CR_ALLOK
*		Если преобразователь не подключет	- CR_NOTCONNECTED
*		Если преобразователь не отвечает	- CR_NOANSWER
*		Другие непонятные ошибки			- CR_OTHERERROR
*************************************************************************************/
CAN_DLL_API CAN_RESULT CAN_SetMask(DWORD MaskValue)

/***********************     CAN_GetMask     ****************************************
*		Возвращает значение маски сети CAN на микроконтроллере.
*		pMaskValue - указатель на переменную, которая будет принимать значение маски
*	Возвращаемые значения:
*		Если все прошло нормально			- CR_ALLOK
*		pMaskValue == NULL					- CR_BADARGUMENTS
*		Если преобразователь не подключет	- CR_NOTCONNECTED
*		Если преобразователь не отвечает	- CR_NOANSWER
*		Другие непонятные ошибки			- CR_OTHERERROR
************************************************************************************/
CAN_DLL_API CAN_RESULT	CAN_GetMask(DWORD* pMaskValue)

/**********************     CAN_COM_Open    ****************************************
*		На платке преобразователя есть также обычный последовательный выход, если 
*	глючный CP2102 не пашет (что обычно бывает при отладке), то эта функция принудительно 
*	инициализирует устройство через последовательный порт
***********************************************************************************/
CAN_DLL_API CAN_RESULT	CAN_COM_Open(unsigned char port_num)

/**************************    CAN_IsCOM_Opened    *********************************
*		Если COM порт был открыт принудительно - то возвращается истина, в противном
*	случае - ложь.В большинстве случаев эта функци не нужна, она может понадобиться, 
*	когда придется распознавать - подключен ли преобразователь к COM порту.
***********************************************************************************/
CAN_DLL_API bool CAN_IsCOM_Opened(void)
