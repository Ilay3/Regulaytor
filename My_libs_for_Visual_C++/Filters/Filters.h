/********************************************************************************************
*********************************************************************************************
**		В этом модуле собраны все фильтры, которые я разрабатывал.
*********************************************************************************************
********************************************************************************************/

/********************************************************************************************
*							ЛИСТ РЕГИСТРАЦИИ ИЗМЕНЕНИЙ
********************************************************************************************/

#pragma once
#include "types_visual_c++.h"		//файл с моими типами


/*******************************************************************************************
*		Это простейшее апериодическое звено первого порядка, однако функции заточены, чтобы
*	фильтровать не равноотстоящие дискретные измерения.
*		T*y'+y=u => T*(y[i]-y[i-1])/h+y[i]=u[i] => y[i]=(u[i]+y[i-1]*(T/h))/(1+T/h)
*		u[i] - вход фильтра на i-м шаге
*		y[i] - выход фильтра на i-м шаге
*		T - постоянная времени фильтра
*		h - время между i-1 и i шагами
*		Чтобы не пороть двусмысленность, я буду измерять время в секундых в FP32, долго, но
*	надежно.
*******************************************************************************************/
struct CAperiodicLinkRandPeriod
{
protected:
	FP32 	m_T;		//постоянная времени фильтра
	FP32 	m_y_1;		//выход на предыдущем шаге
public:
	//конструктор
	CAperiodicLinkRandPeriod();
	CAperiodicLinkRandPeriod(FP32 FreqCutOff_hz, FP32 StartValue=0){Init(FreqCutOff_hz,StartValue);};
	//инициализирует фильтр
	virtual bool Init(FP32 FreqCutOff_hz, FP32 StartValue=0);
	//задает частоту среза фильтра
	bool SetFreqCutOff(FP32 FreqCutOff_hz);
	//собственно функция фильтрации
	virtual FP32 Calculate(FP32 input, FP32 period_s);
};

/*************************************************************************************
*		Это надстройка над CAperiodicLinkRandPeriod, в которой период между шагами
*	дискретизации считатеся автоматически на основании GetTickCount().
*************************************************************************************/
struct CAperiodicLinkRandPeriodAutoStep: public CAperiodicLinkRandPeriod
{	
protected:
	INT32U	m_PredTime;	//В общем, я посчитал удобным возможность не задавать на каждом 
						//шаге h, а считать его автоматически функцией GetTickCount()
						// Производительность, конечно упадет, но удобство появится
public:
	//конструктор
	CAperiodicLinkRandPeriodAutoStep();
	CAperiodicLinkRandPeriodAutoStep(FP32 FreqCutOff_hz, FP32 StartValue=0);
	//собственно функция фильтрации
	//период вычисляется автоматически с помощью GetTickCount()
	FP32 Calculate(FP32 input, INT32U *pPeriod_ms=NULL);
	//Вместо входного значения автоматически подставляется обратная периоду величина
	FP32 FreqCalculate(INT32U *pPeriod_ms=NULL);
};

bool GetOptimalPointsCount_LF(INT16U MaxCount, FP32 ThresholdFrequency, FP32 SampleRate, INT16U* pOptimalCount);
bool CreateCorsWeighting_LF(FP32 *pMas,INT16U Size, FP32 ThresholdFrequency, FP32 SampleRate);
bool ProcessHamming(FP32 *pMas,INT16U Size, FP32 ThresholdFrequency, FP32 SampleRate);