/*
*************************************************************************************************
*	Этот класс отвечает за связь программы на компьютере с объектом управления. В нем прописываются 
*	форматы посылки	очередность их отправки, подсчет контрольной суммы и т.д. Также здесь ведется и
*	передача, прием, распознавание пакетов. Для корректной работы этого класса нужно иметь:
*		- главный класс, в котором содержатся переменные объекта (по котрым и будет формироваться
*		  посылка и куда будет расшифровываться принятый пакет
*		- окошко с кнопочками и настройками (рекомендуется его взять из уже работающего и отлаженного
*		  проекта)
*		- прямые руки...
**************************************************************************************************
*/

/******************** ЛИСТ РЕГИСТРАЦИИ ИЗМЕНЕНИЙ *************************************************
*	8.08.2007 - т.к. теперь есть отдельная DLL, то все изменения пишутся в одно место:
*					USARTDlg.h
*****************************************************************************************************/

#pragma once
#include <ERRORS\ERRORS.h>						//журнал регистрации сообщений
#include <ProtocolOptions\ProtocolOptions.h>	//основной класс с настройками
#include <Hex_and_String\Hex_and_String.h>		//строковое отображение двоичных буферов
#include <MessageClass\MessageClass.h>			//класс отправляемого сообщения
#include <types_visual_c++.h>					//файл с моими типами
#include <ByteStuffing\ByteStuffing.h>			//Функция для перекомпилирования с байтстаффингом
#include <fstream>								//для работы с файлами
using namespace std;


//указатель на главное окно связи
class CUSART_Dlg;

class AFX_EXT_CLASS PROTOCOL_Struct
{
	/*DECLARE_DYNAMIC(PROTOCOL_Struct)*/
public:
	CUSART_Dlg *pUSART_Dlg;

	INT16U Mode; //выбранный режим по которому функционирует протокол отправки
	
	INT64U InMessageCount; //количество полученных пакетов
	
	INT64U OutMessageCount;//количество отправленных пакетов
	
	//ИМЕННО ЭТО СООБЩЕНИЕ И БУДЕТ ОТПРАВЛЯТЬСЯ
	CMessage NextMessage;	//готовое к отправке сообщение типа 1 (одно большое)

	//С 1 по 8 определены в protokol_options.h
	//а это не указатели на функции, т.к. их структура не отличается от программы к программе
	bool CompileMessage_9(CMessage &nextmessage); //РУЧНАЯ КОРРЕКТИРОВКА ПОСЫЛКИ
	bool CompileMessage_10(CMessage &nextmessage);//ПЕРЕДАЧА ИЗ ФАЙЛА

	unsigned char *ReceiveMessage;	//последнее получаемое сообщение, после того как будет принято полностью - 
									//расшифруется и запишется в файл

	ERROR_Class *m_pError;			//указатель на приемник ошибок
	
	//добавляет количество принятых пакетов
	bool AddInMessageCount(void);
	//стирает количество принятых пакетов
	bool ClearInMessageCount(void);

	//добавляет количество отправленных пакетов
	bool AddOutMessageCount(void);
	//стирает количество отправленных пакетов
	bool ClearOutMessageCount(void);

	//собирает новое сообщение по данным основной структуры
	bool CompileALL(void);

	//дописывает полученный  символ, проверяет чек-сумму, максимальную длину,
	//окончание старого и начало нового пакета. Короче элементарные вещи.
	bool ReceiveChar(INT8U ch);
	
	fstream OutMessageFile;			// Из этого файла посылаются сообщения
	ofstream ReceiveMessageFile;	//файл листинга полученных сообщений
	
	
	//Записывает в файл принятые/отправленные/ошибочные сообщения
	#define UART_MSG_TRANSEIVED		0x01	//сообщение отправлено
	#define UART_MSG_RECEIVED		0x02	//сообщение принято
	#define UART_MSG_NOTTRANCEIVED	0x03	//неудачная попытка отправить сообщение
	bool WriteMesFile(CMessage *pMessage, INT8U code);

	//Флаг того, что файл принятых по сети сообщений был открыт,
	//если нет, то программа АВТОМАТИЧЕСКИ его открывает
	bool InMesFileOpened;	// true - файл был открыт
							// false - файл открыт не был
	// открываем файл листинга полученных сообщений
	bool InMesFileOpen(void);
	// открывает файл отправки сообщений
	bool OutMesFileOpen(void);
	// сбрасывает указатель в файле, из которого читаются сообщения
	void BeginOutMesFile(void);

	/**********************************************************************
	*		В этой структуре храняться все настройки протокола, как о формате
	*	пакета с данными, так и настройках порта. И хотя я считаю, что далеко
	*	не всем им здесь место, т.к. например настройка порта - дело не этого
	*	модуля (да и происходит дублирование с SerialPort.h, но просто пусть 
	*	все они храняться в одном месте
	***********************************************************************/
	POTOCOL_OPTIONS_Struct * pProtocolOptions;

	PROTOCOL_Struct(void);//конструктор
	~PROTOCOL_Struct(void);//деструктор
	bool InitPROTOCOL(CUSART_Dlg * pUSART_Dlg, ERROR_Class * error);//вторичная инициализация внутренних переменных
};
