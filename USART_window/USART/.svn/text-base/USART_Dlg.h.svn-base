/********************************************************************************************
*********************************************************************************************
**		Этот модуль содержит библиотеку, которая работает со связью RS232, RS485 и т.д. из 
**	этой же серии. Имеется куча окон и дополнительных классов. Для настройки во внешнем приложе-
**	нии нужно включить этот файл и библиотек, например так:
**		#pragma comment(lib,"USART.lib")
**		#include <USART_window\USART\USART_Dlg.h"
**		Класс не может быть определен во внешнем файле как статический, т.к. собсно создание 
**	окна должно происходить внутри DLL, поэтому поставлена защита.
*********************************************************************************************
********************************************************************************************/

/****************************	ЛИСТ РЕГИСТРАЦИИ ИЗМЕНЕНИЙ	***************************
*	14.04.2007г. - первая версия, которая запускается пока еще с глюками, но уже 
*	полностью автономно.
*	18.06.2007 - введена начальная загрузка конкретного порта, а не первого свободного
*	21.06.2007 - полностью перелопачен алгоритм, я еще на шаг приблизился к идеалу
*	8.07.2007 - в функции Receivechar при приеме с байтстаффингом удален каприз Сергей
*				Владимировича
*	17.07.2007 - теперь окно непосредственной настройки порта вроде работает без ошибок
*	22.07.2007 - более качаственным сделан вызов externReceiveChar. Класс PROTOCOLO_Struct
*				задекларирован AFX_EXT_CLASS, чтобы его функции были видны в DLL
*				Наконец-то я избавился от жесткой привязки путей моих библиотек, теперь
*				они задаются в настройках проекта
*	1.08.07 - уничтожена невостребованная функция InitTestDLL()
*	20.08.07 - Добавлены функции SetMode и GetMode, позволяющие более корректно менять режим приемопередачи
*	26.08.07 - Диалог ConfigDlg теперь работает
*	02.09.07 - Доступен режим, когда ни один из СОМ портов не проинициализирован
*	05.09.07 - Добавлен отлов ситуации, когда пропадает доступ к порту
*	14.09.07 - В NotifyProgram теперь передается сообщение и об ошибке в отправке
*				Теперь числовые значения флагов заменены именованными константами
*				Избавились от кнопки SUM_ER
*	11.10.07 - Разобрался с периодами при непрерывной передаче и эмуляции. Подправил окно
*				настроек. Появилась возможность фиксировать время приема и отправки сообщений.
*	12.11.07 - Теперь отправляемое сообщение пишется в файл, когда оно действительно отправлено
*	6.12.07 - Исправлен, глюк, по которому после показа диалога настроек пропадала запись в
*				файл принимаемых сообщений
*	9.11.07 - Запись времени идет как 12:07 а не как 12:7
*	14.01.08 - в FlagsDlg.cpp исправлены некоторые warningi
*	3.07.2008 - куча мелких доработок, в логфайл стали писаться неотправленные из-за ошибок 
*				сообщения. Добавлена функция ClosePort
*	25.07.2008 - эмуляция приемопередачи проверена и подправлена где надо
*	14.08.2008 - изменения в функции ReSetCOM_Port и MyInit
*	16.09.2008 - В функции ClosePort теперь также выставляется PN_NOTINITIALIZED
**************************************************************************************/

#pragma once
#include <SerialPort\SerialPort.h>											//класс работы с последовательным портом
#include <RealTimer\RealTimer.h>											//точные таймеры
#include <ERRORS\ERRORS.h>													//для регистрации ошибок
#include <ProtocolOptions\ProtocolOptions.h>								//настройки протокола
#include <ColorEdit\ColorEdit.h>											//класс цветных эдитиков

#include "PROTOCOL_Struct.h"												//файл с протоколом

/****************************************************************************************
*		ЗАДЕКЛАРИРУЕМ ВНЕШИНЕ КЛАССЫ
****************************************************************************************/
struct AFX_EXTENSION_MODULE;
class PROTOCOL_Struct;

class AFX_EXT_CLASS CUSART_Dlg : public CDialog
{
	DECLARE_DYNAMIC(CUSART_Dlg)

public:
	ERROR_Class* m_pError;
	CUSART_Dlg(CWnd* pParent = NULL, UINT ID=0);   // standard constructor
	

	// источник IDC_SEND (кол-во отправленных пакетов)
	CStatic m_sended;
	// источник принятых пакетов
	CStatic m_Recieve;

	// источник поле ручной настройка посылки
	CEdit m_OutMessage;
	afx_msg void OnEnChangeOutMessage();

	// источник принятого сообщения IDC_INMESSAGE
	CEdit m_ReceiveMessage;
	// источник ошибки при приеме
	CColorEdit m_InMessageError;
	// источник ошибки при передачи
	CColorEdit m_OutMessageError;

	// показывает ошибку в принимаемом сообщении
	void ShowERROR_in_input_message(CString error , char importence);

	// показывает на экране отправляемое сообщение
	void ShowOutputMessage(void);
	// показывает ошибку в отправляемом сообщении
	void ShowERROR_in_out_message(CString error , char importence);
	
	//вызывается, когда кликнули на кнопку СТАРТ!/СТОП!
	afx_msg void OnStart();
	//функция начинает передачу
	bool StartTransfer(void);
	//функция оканчивает передачу
	bool StopTransfer(void);

	//Когда хотим показать файл листинга полученных по сети сообщений
	afx_msg void OnFile();
	
	//переменная как-то связанная с внутренностью библиотеки
	AFX_EXTENSION_MODULE * pUSARTDLL;

	//для портов
	CSerialPort		m_Ports;
	//функция, настраивающая СОМ порт с определенным номером
	bool ReSetCOMport(INT8U num);

	//класс реального времени
	RealTimer_CLASS RealTimer;

	//Для инициализации критических секций
	CRITICAL_SECTION	m_csTime;

	// описывает протокол приемо-передачи
	PROTOCOL_Struct *pPROTOCOL;

//	bool user_flag;	//используется при передаче

	//источник списка доступных для отправки сообщений
	CComboBox m_ListPacket;

	//создание
	virtual BOOL Create(UINT ID, CWnd* pParentWnd = NULL);

	//блин, пускай все дополнительные классы инициализируются в отдельной функции
	bool MyInit(ERROR_Class* m_ERROR, POTOCOL_OPTIONS_Struct* pProtokolOptions,PROTOCOL_Struct *protocol);

	//дружественная функция для уничтожения динамически созданного окна
	//находится в USART_Dlg.cpp
	friend void DestroyUSART(CUSART_Dlg* pDlg);
	
protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support

	DECLARE_MESSAGE_MAP()

	// нужно для подсчета символов при эмуляции приема и только
	unsigned int char_count;

	//нажали кнопку распознать посылку
	afx_msg void OnVerify();
	//выбрали новый тип протокола передачи
	afx_msg void OnVibor();

	//таймер для эмуляции приемо-передачи
	UINT_PTR my_timer;
	
	//для таймера эмуляции
	afx_msg void OnTimer(UINT nIDEvent);

	//показать опции
	afx_msg void OnBnClickedOptions();

	//чтобы в CEdit были разные цвета
	afx_msg HBRUSH OnCtlColor(CDC* pDC, CWnd* pWnd, UINT nCtlColor);

	//диалог появляется на экране
	virtual BOOL OnInitDialog();

	//приняли очередной символ
	afx_msg LONG OnCommunication(UINT, LONG);
	//окончание передачи
	afx_msg LONG OnTXEmpty(UINT, LONG);
	//запрещен доступ к порту
	afx_msg LONG PortFailure(UINT, LONG);


	/****************************************************************************
	*	Я специально поместил сюда деструктор, чтобы предотвратить создание 
	*	статических объектов вне этой DLL (которые и так бы не были рабочими
	****************************************************************************/
	virtual ~CUSART_Dlg();

	/***************************************************************************
	*	Переменные, которыу будут отслеживать состояние передачи
	*	Все обслуживание этих переменных должно вестись только внутри этого класса
	****************************************************************************/
	protected:
	//флаг того, началась ли передача
	bool IsStarted;
	//сколько отправленных пакетов назад было принято удачное сообщение
	int	 LastGoodReceived;

	public:
	//а это для внешних классов
	bool GetIsStarted(void);
	int	 GetLastGoodReceived(void);

	/****************************************************************************
	*	хэндл глобального события начала передачи
	******************************************************************************/
	HANDLE HGlobalStart;
	bool GlobalStartTranceiving(void);
	bool GlobalStopTranceiving(void);
	/****************************************************************************
	*	хэндл временной занятости передатчика
	****************************************************************************/
	HANDLE HTranceiverBusi;
	bool SetTranceiverBusi(void);
	bool ClearTranceiverBusi(void);

	/****************************************************************************
	*	Функция, отправляющая сообщение
	****************************************************************************/
	bool TranseiveMessage(CMessage* pMessage);
protected:
	virtual void OnOK();

public:
	//функция выставляет номер отправляемого сообщения
	bool SetMode(INT16U mode);
	//функция возвращает номер отправляемого сообщения
	INT16U GetMode();

protected:
	CMessage* pTranceivingMessage;	//В период когда по последовательному порту отправлятеся
									//какое-то сообщение, этот указатель ссылается на него
									//Если в данный момент никакое сообщение не отправляется,
									//он равен нулю
public:
	void ClosePort(void);			//закрывает работу с портом
};

/************************************************************************************
*		Функции, которые вместес классом экспортируются из библиотеки
***************************************************************************************/
//Функция создания всех окон, касающихся связи
extern "C" __declspec (dllexport) CUSART_Dlg* InitUSART_Window(CWnd* pParent, ERROR_Class* m_ERROR, POTOCOL_OPTIONS_Struct* pProtokolOptions);

